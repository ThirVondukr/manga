directive @isAuthenticated on FIELD_DEFINITION

type AltTitle {
  id: ID!
  language: LanguageEnum!
  title: String!
}

type AuthMutations {
  signUp(input: SignUpInput!): SignUpPayload!
  signIn(input: SignInInput!): SignInPayload!
}

type AuthenticationResult {
  user: UserGQL!
  accessToken: String!
}

"""Date with time (isoformat)"""
scalar DateTime

type EntityAlreadyExistsError implements Error {
  message: String!
}

interface Error {
  message: String!
}

type Group {
  id: ID!
  name: String!
}

union GroupCreateError = ValidationErrors | EntityAlreadyExistsError

input GroupCreateInput {
  name: String!
}

type GroupCreatePayload {
  group: Group
  error: GroupCreateError
}

type GroupMutations {
  create(input: GroupCreateInput!): GroupCreatePayload! @isAuthenticated
}

type InvalidCredentialsError implements Error {
  message: String!
}

enum LanguageEnum {
  eng
  ukr
}

type Manga {
  id: ID!
  title: String!
  titleSlug: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  tags: [MangaTag!]!
  altTitles: [AltTitle!]!
}

union MangaCreateError = ValidationErrors

input MangaCreateInput {
  title: String!
}

type MangaCreatePayload {
  manga: Manga
  error: MangaCreateError
}

input MangaFilter {
  searchTerm: String = null
  tags: MangaTagFilter = null
}

type MangaMutations {
  create(input: MangaCreateInput!): MangaCreatePayload!
}

type MangaPagePaginationResult {
  items: [Manga!]!
  pageInfo: PagePaginationInfo!
}

type MangaTag {
  id: ID!
  name: String!
  slug: String!
}

input MangaTagFilter {
  include: [String!] = null
  exclude: [String!] = null
}

type Mutation {
  auth: AuthMutations!
  manga: MangaMutations!
  groups: GroupMutations!
}

type PagePaginationInfo {
  currentPage: Int!
  pageSize: Int!
  totalItems: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  totalPages: Int!
}

input PagePaginationInput {
  page: Int! = 1
  pageSize: Int! = 100
}

type Query {
  manga(id: ID!): Manga
  mangas(pagination: PagePaginationInput = null, filter: MangaFilter = null): MangaPagePaginationResult!
}

union SignInErrors = InvalidCredentialsError | ValidationErrors

input SignInInput {
  email: String!
  password: String!
}

type SignInPayload {
  result: AuthenticationResult
  error: SignInErrors
}

union SignUpErrors = EntityAlreadyExistsError | ValidationErrors

input SignUpInput {
  email: String!
  username: String!
  password: String!
}

type SignUpPayload {
  result: AuthenticationResult
  error: SignUpErrors
}

type UserGQL {
  id: ID!
  username: String!
}

type ValidationError implements Error {
  message: String!
  code: String!
  location: [String!]!
}

type ValidationErrors implements Error {
  message: String!
  errors: [ValidationError!]!
}