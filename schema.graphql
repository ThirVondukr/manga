directive @isAuthenticated on FIELD_DEFINITION

type AltTitle {
  id: ID!
  language: LanguageEnum!
  title: String!
}

type AuthMutations {
  signUp(input: SignUpInput!): SignUpPayload!
  signIn(input: SignInInput!): SignInPayload!
}

type AuthenticationResult {
  user: PrivateUser!
  accessToken: String!
}

"""Date with time (isoformat)"""
scalar DateTime

type EntityAlreadyExistsError implements Error {
  message: String!
}

interface Error {
  message: String!
}

type Group {
  id: ID!
  name: String!
}

union GroupCreateError = ValidationErrors | EntityAlreadyExistsError

input GroupCreateInput {
  name: String!
}

type GroupCreatePayload {
  group: Group
  error: GroupCreateError
}

type GroupMutations {
  create(input: GroupCreateInput!): GroupCreatePayload! @isAuthenticated
}

type InvalidCredentialsError implements Error {
  message: String!
}

enum LanguageEnum {
  ENG
  UKR
}

type Manga {
  id: ID!
  title: String!
  titleSlug: String!
  status: MangaStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  tags: [MangaTag!]!
  altTitles: [AltTitle!]!

  """Manga rating, from 0 to 10"""
  rating: Float!
  bookmarkCount: Int!
  commentCount: Int!
}

union MangaBookmarkError = NotFoundError

type MangaBookmarkPayload {
  manga: Manga
  error: MangaBookmarkError
}

type MangaBranch {
  id: ID!
  name: String!
  language: LanguageEnum!
}

union MangaBranchCreateError = ValidationErrors | RelationshipNotFoundError

input MangaBranchCreateInput {
  name: String!
  language: LanguageEnum!
  mangaId: ID!
}

type MangaBranchCreatePayload {
  branch: MangaBranch
  error: MangaBranchCreateError
}

type MangaBranchMutationGQL {
  create(input: MangaBranchCreateInput!): MangaBranchCreatePayload! @isAuthenticated
}

union MangaCreateError = ValidationErrors

input MangaCreateInput {
  title: String!
  status: MangaStatus!
}

type MangaCreatePayload {
  manga: Manga
  error: MangaCreateError
}

input MangaFilter {
  searchTerm: String = null
  tags: MangaTagFilter = null
}

type MangaMutations {
  create(input: MangaCreateInput!): MangaCreatePayload! @isAuthenticated
  addBookmark(id: ID!): MangaBookmarkPayload! @isAuthenticated
  removeBookmark(id: ID!): MangaBookmarkPayload! @isAuthenticated
}

type MangaPagePaginationResult {
  items: [Manga!]!
  pageInfo: PagePaginationInfo!
}

enum MangaStatus {
  ONGOING
  COMPLETED
  CANCELLED
  ON_HOLD
}

type MangaTag {
  id: ID!
  name: String!
  slug: String!
}

input MangaTagFilter {
  include: [String!] = null
  exclude: [String!] = null
}

type Mutation {
  auth: AuthMutations!
  manga: MangaMutations!
  groups: GroupMutations!
  branches: MangaBranchMutationGQL!
}

type NotFoundError implements Error {
  message: String!
  entityId: ID!
}

type PagePaginationInfo {
  currentPage: Int!
  pageSize: Int!
  totalItems: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  totalPages: Int!
}

input PagePaginationInput {
  page: Int! = 1
  pageSize: Int! = 100
}

type PrivateUser implements User {
  id: ID!
  username: String!
  joinedAt: DateTime!
  email: String!
}

type Query {
  manga(id: ID!): Manga
  mangas(pagination: PagePaginationInput = null, filter: MangaFilter = null): MangaPagePaginationResult!
  me: PrivateUser! @isAuthenticated
  tags: [MangaTag!]!
}

type RelationshipNotFoundError implements Error {
  message: String!
  entityId: ID!
}

union SignInErrors = InvalidCredentialsError | ValidationErrors

input SignInInput {
  email: String!
  password: String!
}

type SignInPayload {
  result: AuthenticationResult
  error: SignInErrors
}

union SignUpErrors = EntityAlreadyExistsError | ValidationErrors

input SignUpInput {
  email: String!
  username: String!
  password: String!
}

type SignUpPayload {
  result: AuthenticationResult
  error: SignUpErrors
}

interface User {
  id: ID!
  username: String!
  joinedAt: DateTime!
}

type ValidationError implements Error {
  message: String!
  code: String!
  location: [String!]!
}

type ValidationErrors implements Error {
  message: String!
  errors: [ValidationError!]!
}