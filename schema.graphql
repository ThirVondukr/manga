directive @cost(complexity: Int!, multiplier: Int) on FIELD_DEFINITION

directive @isAuthenticated on FIELD_DEFINITION

type AltTitle {
  id: ID!
  language: LanguageEnum!
  title: String!
}

type AuthMutations {
  signUp(input: SignUpInput!): SignUpPayload!
  signIn(input: SignInInput!): SignInPayload!
}

type AuthenticationResult {
  user: PrivateUser!
  accessToken: String!
}

union ChapterCreateError = ValidationErrors | FileUploadError | RelationshipNotFoundError | PermissionDeniedError | EntityAlreadyExistsError

input ChapterCreateInput {
  title: String!
  volume: Int
  number: [Int!]!
  branchId: ID!
}

type ChapterCreatePayload {
  chapter: MangaChapter
  error: ChapterCreateError
}

type ChapterMutationGQL {
  create(pages: [Upload!]!, input: ChapterCreateInput!): ChapterCreatePayload! @isAuthenticated
}

"""Date with time (isoformat)"""
scalar DateTime

type EntityAlreadyExistsError implements Error {
  message: String!
}

interface Error {
  message: String!
}

type FileUploadError implements Error {
  message: String!
}

type Group {
  id: ID!
  name: String!
}

union GroupCreateError = ValidationErrors | EntityAlreadyExistsError

input GroupCreateInput {
  name: String!
}

type GroupCreatePayload {
  group: Group
  error: GroupCreateError
}

type GroupMutations {
  create(input: GroupCreateInput!): GroupCreatePayload! @isAuthenticated
}

type InvalidCredentialsError implements Error {
  message: String!
}

enum LanguageEnum {
  ENG
  UKR
}

type Manga {
  id: ID!
  title: String!
  titleSlug: String!
  status: MangaStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  tags: [MangaTag!]!
  chapters(pagination: PagePaginationInput = null): MangaChapterPagePaginationResult!
  altTitles: [AltTitle!]!

  """Manga rating, from 0 to 10"""
  rating: Float!
  bookmarkCount: Int!
  commentCount: Int!
  bookmark: MangaBookmark @isAuthenticated
}

type MangaBookmark {
  id: ID!
  createdAt: DateTime!
}

union MangaBookmarkError = NotFoundError

type MangaBookmarkPayload {
  manga: Manga
  error: MangaBookmarkError
}

type MangaBranch {
  id: ID!
  name: String!
  language: LanguageEnum!
}

union MangaBranchCreateError = ValidationErrors | RelationshipNotFoundError

input MangaBranchCreateInput {
  name: String!
  language: LanguageEnum!
  mangaId: ID!
  groupId: ID!
}

type MangaBranchCreatePayload {
  branch: MangaBranch
  error: MangaBranchCreateError
}

type MangaBranchMutationGQL {
  create(input: MangaBranchCreateInput!): MangaBranchCreatePayload! @isAuthenticated
}

type MangaChapter {
  id: ID!
  title: String!
  volume: Int
  number: String!
  pages: [MangaPage!]!
}

type MangaChapterPagePaginationResult {
  items: [MangaChapter!]!
  pageInfo: PagePaginationInfo!
}

union MangaCreateError = ValidationErrors | EntityAlreadyExistsError

input MangaCreateInput {
  title: String!
  status: MangaStatus!
}

type MangaCreatePayload {
  manga: Manga
  error: MangaCreateError
}

input MangaFilter {
  statuses: [MangaStatus!] = null
  searchTerm: String = null
  tags: MangaTagFilter = null
}

type MangaMutations {
  create(input: MangaCreateInput!): MangaCreatePayload! @isAuthenticated
  addBookmark(id: ID!): MangaBookmarkPayload! @isAuthenticated
  removeBookmark(id: ID!): MangaBookmarkPayload! @isAuthenticated
}

type MangaPage {
  id: ID!
  number: Int!
  image: String!
}

type MangaPagePaginationResult {
  items: [Manga!]!
  pageInfo: PagePaginationInfo!
}

input MangaSort {
  field: MangaSortField! = TITLE
  direction: SortDirection! = ASC
}

enum MangaSortField {
  TITLE
  CREATED_AT
  CHAPTER_UPLOAD
}

enum MangaStatus {
  ONGOING
  COMPLETED
  CANCELLED
  ON_HOLD
}

type MangaTag {
  id: ID!
  name: String!
  slug: String!
  category: MangaTagCategory!
}

type MangaTagCategory {
  id: ID!
  name: String!
}

input MangaTagFilter {
  include: [String!] = null
  exclude: [String!] = null
}

type Mutation {
  auth: AuthMutations!
  manga: MangaMutations!
  groups: GroupMutations!
  branches: MangaBranchMutationGQL!
  chapters: ChapterMutationGQL!
}

type NotFoundError implements Error {
  message: String!
  entityId: ID!
}

type PagePaginationInfo {
  currentPage: Int!
  pageSize: Int!
  totalItems: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  totalPages: Int!
}

input PagePaginationInput {
  page: Int! = 1
  pageSize: Int! = 100
}

type PermissionDeniedError implements Error {
  message: String!
}

type PrivateUser implements User {
  id: ID!
  username: String!
  joinedAt: DateTime!
  email: String!
}

type Query {
  chapter(id: ID!): MangaChapter
  manga(id: ID!): Manga @cost(complexity: 1)
  mangas(pagination: PagePaginationInput = null, filter: MangaFilter = null, sort: MangaSort = null): MangaPagePaginationResult!
  me: PrivateUser! @isAuthenticated
  tags: [MangaTag!]!
}

type RelationshipNotFoundError implements Error {
  message: String!
  entityId: ID!
}

union SignInErrors = InvalidCredentialsError | ValidationErrors

input SignInInput {
  email: String!
  password: String!
}

type SignInPayload {
  result: AuthenticationResult
  error: SignInErrors
}

union SignUpErrors = EntityAlreadyExistsError | ValidationErrors

input SignUpInput {
  email: String!
  username: String!
  password: String!
}

type SignUpPayload {
  result: AuthenticationResult
  error: SignUpErrors
}

enum SortDirection {
  ASC
  DESC
}

scalar Upload

interface User {
  id: ID!
  username: String!
  joinedAt: DateTime!
}

type ValidationError implements Error {
  message: String!
  code: String!
  location: [String!]!
}

type ValidationErrors implements Error {
  message: String!
  errors: [ValidationError!]!
}
